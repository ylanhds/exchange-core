非常好！将 exchange-core 作为研究兴趣是一个绝佳的选择，它融合了高性能计算、数据结构、并发编程和金融科技等多个前沿领域。

你可以按照以下路径，由浅入深地进行学习和研究：

### 第一阶段：理解基础与核心概念 (1-2 周)

在开始看代码之前，必须先理解其背后的理论，否则会感到非常困惑。

1.  **订单匹配引擎 (Matching Engine) 基础**：
    *   **核心概念**： 了解什么是限价订单簿 (Limit Order Book, LOB)、市价单、限价单、GTC/IOC/FOK 等订单类型、买卖盘口 (Bid/Ask)、深度、撮合逻辑（价格优先、时间优先）。
    *   **学习资源**： 在网上搜索 "Limit Order Book explained" 会有很多图文和视频资料。这是所有交易系统的核心。

2.  **核心技术栈概览**：
    *   **LMAX Disruptor**: 理解它为什么快（环形数组、缓存行填充、无锁设计、预分配）。它是整个系统的并发骨架。必读 Martin Fowler 的 [文章](https://martinfowler.com/articles/lmax.html) 和官方论文。
    *   **Eclipse Collections**: 高性能的 Java 集合库，用于替代标准库的 `ArrayList`, `HashMap` 等，减少开销。
    *   **Agrona**: 提供高性能的数据结构（如 `DirectBuffer`) 和工具类，常用于零拷贝（Zero-Copy）编程。
    *   **自适应基数树 (ART)**: 理解为什么用它来存储订单簿（基于价格查找订单），相比传统的红黑树或哈希表，它在内存效率和缓存友好性上的优势。这是订单簿高性能的关键数据结构之一。

### 第二阶段：搭建环境与宏观分析 (1 周)

1.  **克隆项目，编译运行**：
    *   `git clone https://github.com/mzheravin/exchange-core.git`
    *   按照 README 中的说明，用 Maven 编译项目。
    *   **首要任务**： 成功运行 `ITCoreExample.java` 测试案例。这是你的“Hello World”，确保你能看到控制台输出下单、成交等日志。使用 Debug 模式运行，一步步跟踪流程。

2.  **绘制系统架构图**：
    *   根据 `ExchangeCore.builder().build()` 的初始化过程，梳理核心模块：
        *   `Disruptor` 的各个 `EventProcessor` (RingBuffer) 是如何设置的？
        *   风险控制 (Risk) 和撮合引擎 (Matching) 是同一个处理阶段还是分开的？
        *   数据是如何在不同组件之间传递的？（注意：大量使用 `ObjectPool` 和复用对象来避免 GC）

3.  **阅读测试代码**：
    *   `src/test` 目录下的测试，特别是 `exchange.core2.tests` 包，是理解系统功能的最佳文档。从简单的单元测试读到复杂的集成测试。

### 第三阶段：深入核心模块研究 (2-4 周)

这是最有趣的部分，可以选择你最感兴趣的模块深入下去。

1.  **订单簿数据结构 (Order Book)**：
    *   定位到 `exchange.core2.core` 包下，找到 `IOrderBook` 接口及其实现（`OrderBookNaiveImpl`, `OrderBookDirectImpl`）。
    *   **研究重点**：
        *   订单是如何存储的？（很可能买盘和卖盘各是一个 ART 树，树的 key 是价格，value 是该价格下的订单列表）
        *   `placeOrder`, `cancelOrder`, `moveOrder` 这几个核心方法是如何实现的？
        *   比较 "Naive" 和 "Direct" 两种实现的区别。为什么 "Direct" 更快？

2.  **风险控制引擎 (Risk Engine)**：
    *   在用户下单前，需要检查他的资金或仓位是否足够。
    *   **研究重点**：
        *   找到风险处理的类（如 `RiskEngine`）。资金和持仓数据是如何组织的？（可能是分片的 `Long2ObjectHashMap` 或 Eclipse Collections 的 `LongObjectMap`）
        *   理解“直盘交易”和“保证金交易”两种模式在风控上的区别。

3.  **事件处理流程 (Disruptor 工作流)**：
    *   跟踪一个 `ApiPlaceOrder` 命令的完整生命周期：
        1.  **接收**： 通过 `ExchangeApi` 提交。
        2.  **序列化**： (如果启用) 写入 Chronicle 日志。
        3.  **风险检查**： 在第一个 Disruptor 环节处理。
        4.  **撮合**： 通过第二个 Disruptor 环节，进入订单簿进行匹配。
        5.  **发布结果**： 匹配结果（成交、拒绝等）通过 `ResultsConsumer` 发送出去。
    *   **研究重点**： 理解整个 pipeline 如何实现无锁和高并发。

### 第四阶段：进阶研究与实验 (持续)

1.  **性能分析与基准测试**：
    *   运行项目自带的性能测试（如 `PerfLatency`）。
    *   学习使用 **JMH** (Java Microbenchmark Harness) 来对单个方法（如 `OrderBookDirectImpl::placeOrder`）进行微基准测试。
    *   使用 **Async-Profiler** 或 **JFR** (Java Flight Recorder) 生成火焰图，分析热点在哪里（是匹配逻辑？是风险查询？还是垃圾回收？）。

2.  **提出优化方案并验证**：
    *   这是你贡献代码的第一步。例如：
        *   能否对某个数据结构进行更极致的优化？（例如，使用 Agrona 的 `DirectBuffer` 来存储订单数据）
        *   某个算法的常数时间能否降低？
        *   是否可以引入新的订单类型？
    *   **重要**： 任何优化都必须有基准测试结果来证明其有效性。

3.  **扩展功能**：
    *   尝试实现 README 中提到的 TODO，比如实现一个最简单的 **REST API 网关**（用一个单独的 Spring Boot 应用，通过 `ExchangeApi` 客户端与核心连接）。
    *   尝试研究并实现 **L2 Market Data** 的推送功能。

### 推荐的学习与研究工具

*   **IDE**: IntelliJ IDEA Ultimate (其调试和绘图功能非常强大)
*   **性能分析**: JMH, Async-Profiler, JFR
*   **绘图工具**: Draw.io 或 Mermaid.js (用于画架构图、序列图、流程图)
*   **文档工具**: 建议用 Markdown 写学习笔记，推荐 Obsidian 或 Typora。

### 总结

入手 exchange-core 的研究是一个“自上而下”再“自下而上”的过程：
1.  **自上而下**：先理解金融交易和系统架构的宏观概念。
2.  **自下而上**：再从代码细节入手，分析数据结构、算法和并发模型。

不要试图一口吃成胖子。从一个简单的测试案例开始，跟踪一个订单的流程，弄懂一个数据结构，然后逐步扩大范围。这个项目代码质量很高，深入研究会让你在高性能 Java 编程方面获得极大的提升。

祝你研究顺利！这是一个非常有价值的课题。